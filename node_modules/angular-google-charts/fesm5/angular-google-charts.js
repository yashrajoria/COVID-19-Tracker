import { Subject, Observable, of, ReplaySubject, combineLatest, fromEvent } from 'rxjs';
import { __assign, __decorate, __param, __metadata, __spread, __values, __rest } from 'tslib';
import { InjectionToken, NgZone, Inject, LOCALE_ID, Optional, ɵɵdefineInjectable, ɵɵinject, Injectable, Component, ChangeDetectionStrategy, EventEmitter, Input, Output, HostBinding, ElementRef, ContentChildren, QueryList, NgModule } from '@angular/core';
import { switchMap, debounceTime } from 'rxjs/operators';

var ChartEditorRef = /** @class */ (function () {
    function ChartEditorRef(editor) {
        this.editor = editor;
        this.doneSubject = new Subject();
        this.addEventListeners();
    }
    /**
     * Gets an observable that is notified when the dialog is saved.
     * Emits either the result if the dialog was saved or `null` if editing was cancelled.
     */
    ChartEditorRef.prototype.afterClosed = function () {
        return this.doneSubject.asObservable();
    };
    /**
     * Stops editing the chart and closes the dialog.
     */
    ChartEditorRef.prototype.cancel = function () {
        this.editor.closeDialog();
    };
    ChartEditorRef.prototype.addEventListeners = function () {
        var _this = this;
        google.visualization.events.addOneTimeListener(this.editor, 'ok', function () {
            google.visualization.events.removeAllListeners(_this.editor);
            var updatedChartWrapper = _this.editor.getChartWrapper();
            _this.doneSubject.next(updatedChartWrapper);
            _this.doneSubject.complete();
        });
        google.visualization.events.addOneTimeListener(this.editor, 'cancel', function () {
            google.visualization.events.removeAllListeners(_this.editor);
            _this.doneSubject.next(null);
            _this.doneSubject.complete();
        });
    };
    return ChartEditorRef;
}());

var GOOGLE_CHARTS_CONFIG = new InjectionToken('GOOGLE_CHARTS_CONFIG');

var DEFAULT_CONFIG = {
    mapsApiKey: '',
    version: 'current',
    safeMode: false
};
var ScriptLoaderService = /** @class */ (function () {
    function ScriptLoaderService(zone, localeId, config) {
        this.zone = zone;
        this.localeId = localeId;
        this.config = config;
        this.scriptSource = 'https://www.gstatic.com/charts/loader.js';
        this.scriptLoadSubject = new Subject();
        this.config = __assign(__assign({}, DEFAULT_CONFIG), (config || {}));
    }
    /**
     * Checks whether `google.charts` is available.
     *
     * If not, it can be loaded by calling `loadChartPackages`.
     *
     * @returns `true` if `google.charts` is available, `false` otherwise.
     */
    ScriptLoaderService.prototype.isGoogleChartsAvailable = function () {
        if (typeof google === 'undefined' || typeof google.charts === 'undefined') {
            return false;
        }
        return true;
    };
    /**
     * Loads the Google Chart script and the provided chart packages.
     * Can be called multiple times to load more packages.
     *
     * When called without any arguments, this will just load the default package
     * containing the namespaces `google.charts` and `google.visualization` without any charts.
     *
     * @param packages The packages to load.
     * @returns A stream emitting as soon as the chart packages are loaded.
     */
    ScriptLoaderService.prototype.loadChartPackages = function () {
        var _this = this;
        var packages = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            packages[_i] = arguments[_i];
        }
        return this.loadGoogleCharts().pipe(switchMap(function () {
            return new Observable(function (observer) {
                var config = {
                    packages: packages,
                    language: _this.localeId,
                    mapsApiKey: _this.config.mapsApiKey,
                    safeMode: _this.config.safeMode
                };
                google.charts.load(_this.config.version, config);
                google.charts.setOnLoadCallback(function () {
                    _this.zone.run(function () {
                        observer.next();
                        observer.complete();
                    });
                });
            });
        }));
    };
    /**
     * Loads the Google Charts script. After the script is loaded, `google.charts` is defined.
     *
     * @returns A stream emitting as soon as loading has completed.
     * If the google charts script is already loaded, the stream emits immediately.
     */
    ScriptLoaderService.prototype.loadGoogleCharts = function () {
        var _this = this;
        if (this.isGoogleChartsAvailable()) {
            return of(null);
        }
        else if (!this.isLoadingGoogleCharts()) {
            var script = this.createGoogleChartsScript();
            script.onload = function () {
                _this.zone.run(function () {
                    _this.scriptLoadSubject.next();
                    _this.scriptLoadSubject.complete();
                });
            };
            script.onerror = function () {
                _this.zone.run(function () {
                    console.error('Failed to load the google charts script!');
                    _this.scriptLoadSubject.error(new Error('Failed to load the google charts script!'));
                });
            };
        }
        return this.scriptLoadSubject.asObservable();
    };
    ScriptLoaderService.prototype.isLoadingGoogleCharts = function () {
        return this.getGoogleChartsScript() != null;
    };
    ScriptLoaderService.prototype.getGoogleChartsScript = function () {
        var _this = this;
        var pageScripts = Array.from(document.getElementsByTagName('script'));
        return pageScripts.find(function (script) { return script.src === _this.scriptSource; });
    };
    ScriptLoaderService.prototype.createGoogleChartsScript = function () {
        var script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = this.scriptSource;
        script.async = true;
        document.getElementsByTagName('head')[0].appendChild(script);
        return script;
    };
    ScriptLoaderService.ctorParameters = function () { return [
        { type: NgZone },
        { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [GOOGLE_CHARTS_CONFIG,] }, { type: Optional }] }
    ]; };
    ScriptLoaderService.ɵprov = ɵɵdefineInjectable({ factory: function ScriptLoaderService_Factory() { return new ScriptLoaderService(ɵɵinject(NgZone), ɵɵinject(LOCALE_ID), ɵɵinject(GOOGLE_CHARTS_CONFIG, 8)); }, token: ScriptLoaderService, providedIn: "root" });
    ScriptLoaderService = __decorate([
        Injectable({ providedIn: 'root' }),
        __param(1, Inject(LOCALE_ID)),
        __param(2, Inject(GOOGLE_CHARTS_CONFIG)), __param(2, Optional()),
        __metadata("design:paramtypes", [NgZone, String, Object])
    ], ScriptLoaderService);
    return ScriptLoaderService;
}());

var ChartEditorComponent = /** @class */ (function () {
    function ChartEditorComponent(scriptLoaderService) {
        this.scriptLoaderService = scriptLoaderService;
        this.initializedSubject = new Subject();
    }
    Object.defineProperty(ChartEditorComponent.prototype, "initialized$", {
        /**
         * Emits as soon as the chart editor is fully initialized.
         */
        get: function () {
            return this.initializedSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    ChartEditorComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.scriptLoaderService.loadChartPackages('charteditor').subscribe(function () {
            _this.editor = new google.visualization.ChartEditor();
            _this.initializedSubject.next(_this.editor);
            _this.initializedSubject.complete();
        });
    };
    ChartEditorComponent.prototype.editChart = function (component, options) {
        var handle = new ChartEditorRef(this.editor);
        this.editor.openDialog(component.chartWrapper, options || {});
        handle.afterClosed().subscribe(function (result) {
            if (result) {
                component.chartWrapper = result;
            }
        });
        return handle;
    };
    ChartEditorComponent.ctorParameters = function () { return [
        { type: ScriptLoaderService }
    ]; };
    ChartEditorComponent = __decorate([
        Component({
            selector: 'chart-editor',
            template: "<ng-content></ng-content>",
            host: { class: 'chart-editor' },
            changeDetection: ChangeDetectionStrategy.OnPush
        }),
        __metadata("design:paramtypes", [ScriptLoaderService])
    ], ChartEditorComponent);
    return ChartEditorComponent;
}());

var ChartType;
(function (ChartType) {
    ChartType["AnnotationChart"] = "AnnotationChart";
    ChartType["AreaChart"] = "AreaChart";
    ChartType["Bar"] = "Bar";
    ChartType["BarChart"] = "BarChart";
    ChartType["BubbleChart"] = "BubbleChart";
    ChartType["Calendar"] = "Calendar";
    ChartType["CandlestickChart"] = "CandlestickChart";
    ChartType["ColumnChart"] = "ColumnChart";
    ChartType["ComboChart"] = "ComboChart";
    ChartType["PieChart"] = "PieChart";
    ChartType["Gantt"] = "Gantt";
    ChartType["Gauge"] = "Gauge";
    ChartType["GeoChart"] = "GeoChart";
    ChartType["Histogram"] = "Histogram";
    ChartType["Line"] = "Line";
    ChartType["LineChart"] = "LineChart";
    ChartType["Map"] = "Map";
    ChartType["OrgChart"] = "OrgChart";
    ChartType["Sankey"] = "Sankey";
    ChartType["Scatter"] = "Scatter";
    ChartType["ScatterChart"] = "ScatterChart";
    ChartType["SteppedAreaChart"] = "SteppedAreaChart";
    ChartType["Table"] = "Table";
    ChartType["Timeline"] = "Timeline";
    ChartType["TreeMap"] = "TreeMap";
    ChartType["WordTree"] = "wordtree";
})(ChartType || (ChartType = {}));

/**
 * Generates a random ID which can be used to uniquely identify an element.
 */
function generateRandomId() {
    // Math.random should be unique because of its seeding algorithm.
    // Convert it to base 36 (numbers + letters), and grab the first 9 characters
    // after the decimal.
    return '_' + Math.random().toString(36).substr(2, 9);
}

var FilterType;
(function (FilterType) {
    FilterType["Category"] = "CategoryFilter";
    FilterType["ChartRange"] = "ChartRangeFilter";
    FilterType["DateRange"] = "DateRangeFilter";
    FilterType["NumberRange"] = "NumberRangeFilter";
    FilterType["String"] = "StringFilter";
})(FilterType || (FilterType = {}));

var ControlWrapperComponent = /** @class */ (function () {
    function ControlWrapperComponent(loaderService) {
        this.loaderService = loaderService;
        /**
         * Emits when an error occurs when attempting to render the control.
         */
        this.error = new EventEmitter();
        /**
         * The control is ready to accept user interaction and for external method calls.
         *
         * Alternatively, you can listen for a ready event on the dashboard holding the control
         * and call control methods only after the event was fired.
         */
        this.ready = new EventEmitter();
        /**
         * Emits when the user interacts with the control, affecting its state.
         * For example, a `stateChange` event will be emitted whenever you move the thumbs of a range slider control.
         *
         * To retrieve an updated control state after the event fired, call `ControlWrapper.getState()`.
         */
        this.stateChange = new EventEmitter();
        /**
         * A generated id assigned to this components DOM element.
         */
        this.id = generateRandomId();
        this.wrapperReadySubject = new ReplaySubject(1);
        this.initialized = false;
    }
    Object.defineProperty(ControlWrapperComponent.prototype, "wrapperReady$", {
        /**
         * Emits after the `ControlWrapper` was created.
         */
        get: function () {
            return this.wrapperReadySubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ControlWrapperComponent.prototype, "controlWrapper", {
        get: function () {
            return this._controlWrapper;
        },
        enumerable: true,
        configurable: true
    });
    ControlWrapperComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.loaderService.loadChartPackages('controls').subscribe(function () {
            _this.createControlWrapper();
            _this.initialized = true;
        });
    };
    ControlWrapperComponent.prototype.ngOnChanges = function (changes) {
        if (!this.initialized) {
            return;
        }
        if (changes.type) {
            this._controlWrapper.setControlType(this.type);
        }
        if (changes.options) {
            this._controlWrapper.setOptions(this.options);
        }
        if (changes.state) {
            this._controlWrapper.setState(this.state);
        }
    };
    ControlWrapperComponent.prototype.createControlWrapper = function () {
        this._controlWrapper = new google.visualization.ControlWrapper({
            containerId: this.id,
            controlType: this.type,
            state: this.state,
            options: this.options
        });
        this.addEventListeners();
        this.wrapperReadySubject.next(this._controlWrapper);
    };
    ControlWrapperComponent.prototype.addEventListeners = function () {
        var _this = this;
        google.visualization.events.removeAllListeners(this._controlWrapper);
        google.visualization.events.addListener(this._controlWrapper, 'ready', function (event) { return _this.ready.emit(event); });
        google.visualization.events.addListener(this._controlWrapper, 'error', function (event) { return _this.error.emit(event); });
        google.visualization.events.addListener(this._controlWrapper, 'statechange', function (event) { return _this.stateChange.emit(event); });
    };
    ControlWrapperComponent.ctorParameters = function () { return [
        { type: ScriptLoaderService }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ControlWrapperComponent.prototype, "for", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ControlWrapperComponent.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ControlWrapperComponent.prototype, "options", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ControlWrapperComponent.prototype, "state", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], ControlWrapperComponent.prototype, "error", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], ControlWrapperComponent.prototype, "ready", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], ControlWrapperComponent.prototype, "stateChange", void 0);
    __decorate([
        HostBinding('id'),
        __metadata("design:type", Object)
    ], ControlWrapperComponent.prototype, "id", void 0);
    ControlWrapperComponent = __decorate([
        Component({
            selector: 'control-wrapper',
            template: '',
            host: { class: 'control-wrapper' },
            exportAs: 'controlWrapper',
            changeDetection: ChangeDetectionStrategy.OnPush
        }),
        __metadata("design:paramtypes", [ScriptLoaderService])
    ], ControlWrapperComponent);
    return ControlWrapperComponent;
}());

var DashboardComponent = /** @class */ (function () {
    function DashboardComponent(element, loaderService) {
        this.element = element;
        this.loaderService = loaderService;
        /**
         * The dashboard has completed drawing and is ready to accept changes.
         *
         * The ready event will also fire:
         * - after the completion of a dashboard refresh triggered by a user or programmatic interaction with one of the controls,
         * - after redrawing any chart on the dashboard.
         */
        this.ready = new EventEmitter();
        /**
         * Emits when an error occurs when attempting to render the dashboard.
         * One or more of the controls and charts that are part of the dashboard may have failed rendering.
         */
        this.error = new EventEmitter();
        this.initialized = false;
    }
    DashboardComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.loaderService.loadChartPackages('controls').subscribe(function () {
            _this.createDataTable();
            _this.createDashboard();
            _this.initialized = true;
        });
    };
    DashboardComponent.prototype.ngOnChanges = function (changes) {
        if (!this.initialized) {
            return;
        }
        if (changes.data || changes.columns) {
            this.createDataTable();
            this.dashboard.draw(this.dataTable);
        }
    };
    DashboardComponent.prototype.createDashboard = function () {
        var _this = this;
        // TODO: This should happen in the control wrapper
        // However, I don't yet know how to do this because then `bind()` would get called multiple times
        // for the same control if something changes. This is not supported by google charts as far as I can tell
        // from their source code.
        var controlWrappersReady$ = this.controlWrappers.map(function (control) { return control.wrapperReady$; });
        var chartsReady$ = this.controlWrappers
            .map(function (control) { return control.for; })
            .map(function (charts) {
            if (Array.isArray(charts)) {
                // CombineLatest waits for all observables
                return combineLatest(charts.map(function (chart) { return chart.wrapperReady$; }));
            }
            else {
                return charts.wrapperReady$;
            }
        });
        // We have to wait for all chart wrappers and control wrappers to be initialized
        // before we can compose them together to create the dashboard
        combineLatest(__spread(controlWrappersReady$, chartsReady$)).subscribe(function () {
            _this.dashboard = new google.visualization.Dashboard(_this.element.nativeElement);
            _this.initializeBindings();
            _this.dashboard.draw(_this.dataTable);
        });
    };
    DashboardComponent.prototype.initializeBindings = function () {
        var _this = this;
        this.controlWrappers.forEach(function (control) {
            if (Array.isArray(control.for)) {
                var chartWrappers = control.for.map(function (chart) { return chart.chartWrapper; });
                _this.dashboard.bind(control.controlWrapper, chartWrappers);
            }
            else {
                _this.dashboard.bind(control.controlWrapper, control.for.chartWrapper);
            }
        });
    };
    DashboardComponent.prototype.createDataTable = function () {
        if (this.data == null) {
            return;
        }
        var firstRowIsData = true;
        if (this.columns != null) {
            firstRowIsData = false;
        }
        this.dataTable = google.visualization.arrayToDataTable(this.getDataAsTable(), firstRowIsData);
    };
    DashboardComponent.prototype.getDataAsTable = function () {
        if (this.columns) {
            return __spread([this.columns], this.data);
        }
        else {
            return this.data;
        }
    };
    DashboardComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ScriptLoaderService }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], DashboardComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], DashboardComponent.prototype, "columns", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], DashboardComponent.prototype, "ready", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], DashboardComponent.prototype, "error", void 0);
    __decorate([
        ContentChildren(ControlWrapperComponent),
        __metadata("design:type", QueryList)
    ], DashboardComponent.prototype, "controlWrappers", void 0);
    DashboardComponent = __decorate([
        Component({
            selector: 'dashboard',
            template: '<ng-content></ng-content>',
            changeDetection: ChangeDetectionStrategy.OnPush,
            exportAs: 'dashboard',
            host: { class: 'dashboard' }
        }),
        __metadata("design:paramtypes", [ElementRef, ScriptLoaderService])
    ], DashboardComponent);
    return DashboardComponent;
}());

var GoogleChartComponent = /** @class */ (function () {
    function GoogleChartComponent(element, scriptLoaderService, dashboard) {
        this.element = element;
        this.scriptLoaderService = scriptLoaderService;
        this.dashboard = dashboard;
        /**
         * The chart-specific options. All options listen in the Google Charts documentation applying
         * to the chart type specified can be used here.
         */
        this.options = {};
        /**
         * If this is set to `true`, the chart will be redrawn if the browser window is resized.
         * Defaults to `false` and should only be used when specifying the width or height of the chart
         * in percent.
         *
         * Note that this can impact performance.
         */
        this.dynamicResize = false;
        this.ready = new EventEmitter();
        this.error = new EventEmitter();
        this.select = new EventEmitter();
        this.mouseover = new EventEmitter();
        this.mouseleave = new EventEmitter();
        this.wrapperReadySubject = new ReplaySubject(1);
        this.initialized = false;
    }
    Object.defineProperty(GoogleChartComponent.prototype, "chart", {
        get: function () {
            if (!this.wrapper) {
                return null;
            }
            return this.wrapper.getChart();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleChartComponent.prototype, "wrapperReady$", {
        get: function () {
            return this.wrapperReadySubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleChartComponent.prototype, "chartWrapper", {
        get: function () {
            return this.wrapper;
        },
        set: function (wrapper) {
            this.wrapper = wrapper;
            this.drawChart();
        },
        enumerable: true,
        configurable: true
    });
    GoogleChartComponent.prototype.ngOnInit = function () {
        var _this = this;
        // We don't need to load any chart packages, the chart wrapper will handle this for us
        this.scriptLoaderService.loadChartPackages().subscribe(function () {
            _this.createDataTable();
            // Only ever create the wrapper once to allow animations to happen when someting changes.
            _this.wrapper = new google.visualization.ChartWrapper({
                container: _this.element.nativeElement,
                chartType: _this.type,
                dataTable: _this.dataTable,
                options: _this.mergeOptions()
            });
            _this.registerChartEvents();
            _this.wrapperReadySubject.next(_this.wrapper);
            _this.initialized = true;
            _this.drawChart();
        });
    };
    GoogleChartComponent.prototype.ngOnChanges = function (changes) {
        if (changes.dynamicResize) {
            this.updateResizeListener();
        }
        if (this.initialized) {
            var shouldRedraw = false;
            if (changes.data || changes.columns || changes.formatters) {
                this.createDataTable();
                this.wrapper.setDataTable(this.dataTable);
                shouldRedraw = true;
            }
            if (changes.type) {
                this.wrapper.setChartType(this.type);
                shouldRedraw = true;
            }
            if (changes.options || changes.width || changes.height || changes.title) {
                this.wrapper.setOptions(this.mergeOptions());
                shouldRedraw = true;
            }
            if (shouldRedraw) {
                this.drawChart();
            }
        }
    };
    GoogleChartComponent.prototype.createDataTable = function () {
        if (this.data == null) {
            return;
        }
        var firstRowIsData = true;
        if (this.columns != null) {
            firstRowIsData = false;
        }
        this.dataTable = google.visualization.arrayToDataTable(this.getDataAsTable(), firstRowIsData);
        this.applyFormatters(this.dataTable);
    };
    GoogleChartComponent.prototype.getDataAsTable = function () {
        if (this.columns) {
            return __spread([this.columns], this.data);
        }
        else {
            return this.data;
        }
    };
    GoogleChartComponent.prototype.updateResizeListener = function () {
        var _this = this;
        if (this.resizeSubscription != null) {
            this.resizeSubscription.unsubscribe();
            this.resizeSubscription = null;
        }
        if (this.dynamicResize) {
            this.resizeSubscription = fromEvent(window, 'resize')
                .pipe(debounceTime(100))
                .subscribe(function () {
                if (_this.initialized) {
                    _this.drawChart();
                }
            });
        }
    };
    GoogleChartComponent.prototype.mergeOptions = function () {
        return __assign({ title: this.title, width: this.width, height: this.height }, this.options);
    };
    GoogleChartComponent.prototype.applyFormatters = function (dataTable) {
        var e_1, _a;
        if (this.formatters == null) {
            return;
        }
        try {
            for (var _b = __values(this.formatters), _c = _b.next(); !_c.done; _c = _b.next()) {
                var val = _c.value;
                val.formatter.format(dataTable, val.colIndex);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    GoogleChartComponent.prototype.registerChartEvents = function () {
        var _this = this;
        google.visualization.events.removeAllListeners(this.wrapper);
        var registerChartEvent = function (object, eventName, callback) {
            google.visualization.events.addListener(object, eventName, callback);
        };
        registerChartEvent(this.wrapper, 'ready', function () {
            // This could also be done by checking if we already subscribed to the events
            google.visualization.events.removeAllListeners(_this.chart);
            registerChartEvent(_this.chart, 'onmouseover', function (event) { return _this.mouseover.emit(event); });
            registerChartEvent(_this.chart, 'onmouseout', function (event) { return _this.mouseleave.emit(event); });
            registerChartEvent(_this.chart, 'select', function () {
                var selection = _this.chart.getSelection();
                _this.select.emit({ selection: selection });
            });
            _this.ready.emit({ chart: _this.chart });
        });
        registerChartEvent(this.wrapper, 'error', function (error) { return _this.error.emit(error); });
    };
    GoogleChartComponent.prototype.drawChart = function () {
        if (this.dashboard != null) {
            // If this chart is part of a dashboard, the dashboard takes care of drawing
            return;
        }
        this.wrapper.draw();
    };
    GoogleChartComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ScriptLoaderService },
        { type: DashboardComponent, decorators: [{ type: Optional }] }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], GoogleChartComponent.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], GoogleChartComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], GoogleChartComponent.prototype, "columns", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], GoogleChartComponent.prototype, "title", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GoogleChartComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GoogleChartComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GoogleChartComponent.prototype, "options", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], GoogleChartComponent.prototype, "formatters", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GoogleChartComponent.prototype, "dynamicResize", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], GoogleChartComponent.prototype, "ready", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], GoogleChartComponent.prototype, "error", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], GoogleChartComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], GoogleChartComponent.prototype, "mouseover", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], GoogleChartComponent.prototype, "mouseleave", void 0);
    GoogleChartComponent = __decorate([
        Component({
            selector: 'google-chart',
            template: '',
            host: { class: 'google-chart' },
            exportAs: 'googleChart',
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [':host { width: fit-content; display: block; }']
        }),
        __param(2, Optional()),
        __metadata("design:paramtypes", [ElementRef,
            ScriptLoaderService,
            DashboardComponent])
    ], GoogleChartComponent);
    return GoogleChartComponent;
}());

var ChartWrapperComponent = /** @class */ (function () {
    function ChartWrapperComponent(element, scriptLoaderService) {
        this.element = element;
        this.scriptLoaderService = scriptLoaderService;
        this.error = new EventEmitter();
        this.ready = new EventEmitter();
        this.select = new EventEmitter();
        this.wrapperReadySubject = new ReplaySubject(1);
        this.initialized = false;
    }
    Object.defineProperty(ChartWrapperComponent.prototype, "chart", {
        get: function () {
            if (!this.wrapper) {
                return null;
            }
            return this.wrapper.getChart();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartWrapperComponent.prototype, "wrapperReady$", {
        get: function () {
            return this.wrapperReadySubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChartWrapperComponent.prototype, "chartWrapper", {
        get: function () {
            return this.wrapper;
        },
        set: function (wrapper) {
            this.wrapper = wrapper;
            this.drawChart();
        },
        enumerable: true,
        configurable: true
    });
    ChartWrapperComponent.prototype.ngOnInit = function () {
        var _this = this;
        // We don't need to load any chart packages, the chart wrapper will handle this else for us
        this.scriptLoaderService.loadChartPackages().subscribe(function () {
            if (!_this.specs) {
                _this.specs = {};
            }
            var _a = _this.specs, containerId = _a.containerId, container = _a.container, specs = __rest(_a, ["containerId", "container"]);
            // Only ever create the wrapper once to allow animations to happen if something changes.
            _this.wrapper = new google.visualization.ChartWrapper(__assign(__assign({}, specs), { container: _this.element.nativeElement }));
            _this.registerChartEvents();
            _this.wrapperReadySubject.next(_this.wrapper);
            _this.drawChart();
            _this.initialized = true;
        });
    };
    ChartWrapperComponent.prototype.ngOnChanges = function (changes) {
        if (!this.initialized) {
            return;
        }
        if (changes.specs) {
            this.updateChart();
            this.drawChart();
        }
    };
    ChartWrapperComponent.prototype.updateChart = function () {
        if (!this.specs) {
            // When creating the wrapper with empty specs, the google charts library will show an error
            // If we don't do this, a javascript error will be thrown, which is not as visible to the user
            this.specs = {};
        }
        this.wrapper.setChartType(this.specs.chartType);
        this.wrapper.setDataTable(this.specs.dataTable); // The typing here are not correct, this also accepts plain arrays
        this.wrapper.setDataSourceUrl(this.specs.dataSourceUrl);
        this.wrapper.setDataSourceUrl(this.specs.dataSourceUrl);
        this.wrapper.setQuery(this.specs.query);
        this.wrapper.setOptions(this.specs.options);
        this.wrapper.setRefreshInterval(this.specs.refreshInterval);
        this.wrapper.setView(this.specs.view);
    };
    ChartWrapperComponent.prototype.drawChart = function () {
        this.wrapper.draw();
    };
    ChartWrapperComponent.prototype.registerChartEvents = function () {
        var _this = this;
        google.visualization.events.removeAllListeners(this.wrapper);
        var registerChartEvent = function (object, eventName, callback) {
            google.visualization.events.addListener(object, eventName, callback);
        };
        registerChartEvent(this.wrapper, 'ready', function () { return _this.ready.emit({ chart: _this.chart }); });
        registerChartEvent(this.wrapper, 'error', function (error) { return _this.error.emit(error); });
        registerChartEvent(this.wrapper, 'select', function () {
            var selection = _this.chart.getSelection();
            _this.select.emit({ selection: selection });
        });
    };
    ChartWrapperComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ScriptLoaderService }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartWrapperComponent.prototype, "specs", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], ChartWrapperComponent.prototype, "error", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], ChartWrapperComponent.prototype, "ready", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], ChartWrapperComponent.prototype, "select", void 0);
    ChartWrapperComponent = __decorate([
        Component({
            selector: 'chart-wrapper',
            template: '',
            host: { class: 'chart-wrapper' },
            exportAs: 'chartWrapper',
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [':host { width: fit-content; display: block; }']
        }),
        __metadata("design:paramtypes", [ElementRef, ScriptLoaderService])
    ], ChartWrapperComponent);
    return ChartWrapperComponent;
}());

var _a;
var ChartTypesToPackages = (_a = {},
    _a[ChartType.AnnotationChart] = 'annotationchart',
    _a[ChartType.AreaChart] = 'corechart',
    _a[ChartType.Bar] = 'bar',
    _a[ChartType.BarChart] = 'corechart',
    _a[ChartType.BubbleChart] = 'corechart',
    _a[ChartType.Calendar] = 'calendar',
    _a[ChartType.CandlestickChart] = 'corechart',
    _a[ChartType.ColumnChart] = 'corechart',
    _a[ChartType.ComboChart] = 'corechart',
    _a[ChartType.PieChart] = 'corechart',
    _a[ChartType.Gantt] = 'gantt',
    _a[ChartType.Gauge] = 'gauge',
    _a[ChartType.GeoChart] = 'geochart',
    _a[ChartType.Histogram] = 'corechart',
    _a[ChartType.Line] = 'line',
    _a[ChartType.LineChart] = 'corechart',
    _a[ChartType.Map] = 'map',
    _a[ChartType.OrgChart] = 'orgchart',
    _a[ChartType.Sankey] = 'sankey',
    _a[ChartType.Scatter] = 'scatter',
    _a[ChartType.ScatterChart] = 'corechart',
    _a[ChartType.SteppedAreaChart] = 'corechart',
    _a[ChartType.Table] = 'table',
    _a[ChartType.Timeline] = 'timeline',
    _a[ChartType.TreeMap] = 'treemap',
    _a[ChartType.WordTree] = 'wordtree',
    _a);
function getPackageForChart(type) {
    return ChartTypesToPackages[type];
}

var GoogleChartsModule = /** @class */ (function () {
    function GoogleChartsModule() {
    }
    GoogleChartsModule_1 = GoogleChartsModule;
    GoogleChartsModule.forRoot = function (config) {
        if (config === void 0) { config = {}; }
        return {
            ngModule: GoogleChartsModule_1,
            providers: [{ provide: GOOGLE_CHARTS_CONFIG, useValue: config }]
        };
    };
    var GoogleChartsModule_1;
    GoogleChartsModule = GoogleChartsModule_1 = __decorate([
        NgModule({
            declarations: [GoogleChartComponent, ChartWrapperComponent, DashboardComponent, ControlWrapperComponent, ChartEditorComponent],
            exports: [GoogleChartComponent, ChartWrapperComponent, DashboardComponent, ControlWrapperComponent, ChartEditorComponent]
        })
    ], GoogleChartsModule);
    return GoogleChartsModule;
}());

/*
 * Public API Surface of angular-google-charts
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ChartEditorComponent, ChartEditorRef, ChartType, ChartWrapperComponent, ControlWrapperComponent, DashboardComponent, FilterType, GoogleChartComponent, GoogleChartsModule, ScriptLoaderService, getPackageForChart, GOOGLE_CHARTS_CONFIG as ɵa };
//# sourceMappingURL=angular-google-charts.js.map
