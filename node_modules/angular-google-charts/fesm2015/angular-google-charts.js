import { Subject, Observable, of, ReplaySubject, combineLatest, fromEvent } from 'rxjs';
import { __decorate, __param, __metadata, __rest } from 'tslib';
import { InjectionToken, NgZone, Inject, LOCALE_ID, Optional, ɵɵdefineInjectable, ɵɵinject, Injectable, Component, ChangeDetectionStrategy, EventEmitter, Input, Output, HostBinding, ElementRef, ContentChildren, QueryList, NgModule } from '@angular/core';
import { switchMap, debounceTime } from 'rxjs/operators';

class ChartEditorRef {
    constructor(editor) {
        this.editor = editor;
        this.doneSubject = new Subject();
        this.addEventListeners();
    }
    /**
     * Gets an observable that is notified when the dialog is saved.
     * Emits either the result if the dialog was saved or `null` if editing was cancelled.
     */
    afterClosed() {
        return this.doneSubject.asObservable();
    }
    /**
     * Stops editing the chart and closes the dialog.
     */
    cancel() {
        this.editor.closeDialog();
    }
    addEventListeners() {
        google.visualization.events.addOneTimeListener(this.editor, 'ok', () => {
            google.visualization.events.removeAllListeners(this.editor);
            const updatedChartWrapper = this.editor.getChartWrapper();
            this.doneSubject.next(updatedChartWrapper);
            this.doneSubject.complete();
        });
        google.visualization.events.addOneTimeListener(this.editor, 'cancel', () => {
            google.visualization.events.removeAllListeners(this.editor);
            this.doneSubject.next(null);
            this.doneSubject.complete();
        });
    }
}

const GOOGLE_CHARTS_CONFIG = new InjectionToken('GOOGLE_CHARTS_CONFIG');

const DEFAULT_CONFIG = {
    mapsApiKey: '',
    version: 'current',
    safeMode: false
};
let ScriptLoaderService = class ScriptLoaderService {
    constructor(zone, localeId, config) {
        this.zone = zone;
        this.localeId = localeId;
        this.config = config;
        this.scriptSource = 'https://www.gstatic.com/charts/loader.js';
        this.scriptLoadSubject = new Subject();
        this.config = Object.assign(Object.assign({}, DEFAULT_CONFIG), (config || {}));
    }
    /**
     * Checks whether `google.charts` is available.
     *
     * If not, it can be loaded by calling `loadChartPackages`.
     *
     * @returns `true` if `google.charts` is available, `false` otherwise.
     */
    isGoogleChartsAvailable() {
        if (typeof google === 'undefined' || typeof google.charts === 'undefined') {
            return false;
        }
        return true;
    }
    /**
     * Loads the Google Chart script and the provided chart packages.
     * Can be called multiple times to load more packages.
     *
     * When called without any arguments, this will just load the default package
     * containing the namespaces `google.charts` and `google.visualization` without any charts.
     *
     * @param packages The packages to load.
     * @returns A stream emitting as soon as the chart packages are loaded.
     */
    loadChartPackages(...packages) {
        return this.loadGoogleCharts().pipe(switchMap(() => {
            return new Observable(observer => {
                const config = {
                    packages,
                    language: this.localeId,
                    mapsApiKey: this.config.mapsApiKey,
                    safeMode: this.config.safeMode
                };
                google.charts.load(this.config.version, config);
                google.charts.setOnLoadCallback(() => {
                    this.zone.run(() => {
                        observer.next();
                        observer.complete();
                    });
                });
            });
        }));
    }
    /**
     * Loads the Google Charts script. After the script is loaded, `google.charts` is defined.
     *
     * @returns A stream emitting as soon as loading has completed.
     * If the google charts script is already loaded, the stream emits immediately.
     */
    loadGoogleCharts() {
        if (this.isGoogleChartsAvailable()) {
            return of(null);
        }
        else if (!this.isLoadingGoogleCharts()) {
            const script = this.createGoogleChartsScript();
            script.onload = () => {
                this.zone.run(() => {
                    this.scriptLoadSubject.next();
                    this.scriptLoadSubject.complete();
                });
            };
            script.onerror = () => {
                this.zone.run(() => {
                    console.error('Failed to load the google charts script!');
                    this.scriptLoadSubject.error(new Error('Failed to load the google charts script!'));
                });
            };
        }
        return this.scriptLoadSubject.asObservable();
    }
    isLoadingGoogleCharts() {
        return this.getGoogleChartsScript() != null;
    }
    getGoogleChartsScript() {
        const pageScripts = Array.from(document.getElementsByTagName('script'));
        return pageScripts.find(script => script.src === this.scriptSource);
    }
    createGoogleChartsScript() {
        const script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = this.scriptSource;
        script.async = true;
        document.getElementsByTagName('head')[0].appendChild(script);
        return script;
    }
};
ScriptLoaderService.ctorParameters = () => [
    { type: NgZone },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [GOOGLE_CHARTS_CONFIG,] }, { type: Optional }] }
];
ScriptLoaderService.ɵprov = ɵɵdefineInjectable({ factory: function ScriptLoaderService_Factory() { return new ScriptLoaderService(ɵɵinject(NgZone), ɵɵinject(LOCALE_ID), ɵɵinject(GOOGLE_CHARTS_CONFIG, 8)); }, token: ScriptLoaderService, providedIn: "root" });
ScriptLoaderService = __decorate([
    Injectable({ providedIn: 'root' }),
    __param(1, Inject(LOCALE_ID)),
    __param(2, Inject(GOOGLE_CHARTS_CONFIG)), __param(2, Optional()),
    __metadata("design:paramtypes", [NgZone, String, Object])
], ScriptLoaderService);

let ChartEditorComponent = class ChartEditorComponent {
    constructor(scriptLoaderService) {
        this.scriptLoaderService = scriptLoaderService;
        this.initializedSubject = new Subject();
    }
    /**
     * Emits as soon as the chart editor is fully initialized.
     */
    get initialized$() {
        return this.initializedSubject.asObservable();
    }
    ngOnInit() {
        this.scriptLoaderService.loadChartPackages('charteditor').subscribe(() => {
            this.editor = new google.visualization.ChartEditor();
            this.initializedSubject.next(this.editor);
            this.initializedSubject.complete();
        });
    }
    editChart(component, options) {
        const handle = new ChartEditorRef(this.editor);
        this.editor.openDialog(component.chartWrapper, options || {});
        handle.afterClosed().subscribe(result => {
            if (result) {
                component.chartWrapper = result;
            }
        });
        return handle;
    }
};
ChartEditorComponent.ctorParameters = () => [
    { type: ScriptLoaderService }
];
ChartEditorComponent = __decorate([
    Component({
        selector: 'chart-editor',
        template: `<ng-content></ng-content>`,
        host: { class: 'chart-editor' },
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [ScriptLoaderService])
], ChartEditorComponent);

var ChartType;
(function (ChartType) {
    ChartType["AnnotationChart"] = "AnnotationChart";
    ChartType["AreaChart"] = "AreaChart";
    ChartType["Bar"] = "Bar";
    ChartType["BarChart"] = "BarChart";
    ChartType["BubbleChart"] = "BubbleChart";
    ChartType["Calendar"] = "Calendar";
    ChartType["CandlestickChart"] = "CandlestickChart";
    ChartType["ColumnChart"] = "ColumnChart";
    ChartType["ComboChart"] = "ComboChart";
    ChartType["PieChart"] = "PieChart";
    ChartType["Gantt"] = "Gantt";
    ChartType["Gauge"] = "Gauge";
    ChartType["GeoChart"] = "GeoChart";
    ChartType["Histogram"] = "Histogram";
    ChartType["Line"] = "Line";
    ChartType["LineChart"] = "LineChart";
    ChartType["Map"] = "Map";
    ChartType["OrgChart"] = "OrgChart";
    ChartType["Sankey"] = "Sankey";
    ChartType["Scatter"] = "Scatter";
    ChartType["ScatterChart"] = "ScatterChart";
    ChartType["SteppedAreaChart"] = "SteppedAreaChart";
    ChartType["Table"] = "Table";
    ChartType["Timeline"] = "Timeline";
    ChartType["TreeMap"] = "TreeMap";
    ChartType["WordTree"] = "wordtree";
})(ChartType || (ChartType = {}));

/**
 * Generates a random ID which can be used to uniquely identify an element.
 */
function generateRandomId() {
    // Math.random should be unique because of its seeding algorithm.
    // Convert it to base 36 (numbers + letters), and grab the first 9 characters
    // after the decimal.
    return '_' + Math.random().toString(36).substr(2, 9);
}

var FilterType;
(function (FilterType) {
    FilterType["Category"] = "CategoryFilter";
    FilterType["ChartRange"] = "ChartRangeFilter";
    FilterType["DateRange"] = "DateRangeFilter";
    FilterType["NumberRange"] = "NumberRangeFilter";
    FilterType["String"] = "StringFilter";
})(FilterType || (FilterType = {}));

let ControlWrapperComponent = class ControlWrapperComponent {
    constructor(loaderService) {
        this.loaderService = loaderService;
        /**
         * Emits when an error occurs when attempting to render the control.
         */
        this.error = new EventEmitter();
        /**
         * The control is ready to accept user interaction and for external method calls.
         *
         * Alternatively, you can listen for a ready event on the dashboard holding the control
         * and call control methods only after the event was fired.
         */
        this.ready = new EventEmitter();
        /**
         * Emits when the user interacts with the control, affecting its state.
         * For example, a `stateChange` event will be emitted whenever you move the thumbs of a range slider control.
         *
         * To retrieve an updated control state after the event fired, call `ControlWrapper.getState()`.
         */
        this.stateChange = new EventEmitter();
        /**
         * A generated id assigned to this components DOM element.
         */
        this.id = generateRandomId();
        this.wrapperReadySubject = new ReplaySubject(1);
        this.initialized = false;
    }
    /**
     * Emits after the `ControlWrapper` was created.
     */
    get wrapperReady$() {
        return this.wrapperReadySubject.asObservable();
    }
    get controlWrapper() {
        return this._controlWrapper;
    }
    ngOnInit() {
        this.loaderService.loadChartPackages('controls').subscribe(() => {
            this.createControlWrapper();
            this.initialized = true;
        });
    }
    ngOnChanges(changes) {
        if (!this.initialized) {
            return;
        }
        if (changes.type) {
            this._controlWrapper.setControlType(this.type);
        }
        if (changes.options) {
            this._controlWrapper.setOptions(this.options);
        }
        if (changes.state) {
            this._controlWrapper.setState(this.state);
        }
    }
    createControlWrapper() {
        this._controlWrapper = new google.visualization.ControlWrapper({
            containerId: this.id,
            controlType: this.type,
            state: this.state,
            options: this.options
        });
        this.addEventListeners();
        this.wrapperReadySubject.next(this._controlWrapper);
    }
    addEventListeners() {
        google.visualization.events.removeAllListeners(this._controlWrapper);
        google.visualization.events.addListener(this._controlWrapper, 'ready', event => this.ready.emit(event));
        google.visualization.events.addListener(this._controlWrapper, 'error', event => this.error.emit(event));
        google.visualization.events.addListener(this._controlWrapper, 'statechange', event => this.stateChange.emit(event));
    }
};
ControlWrapperComponent.ctorParameters = () => [
    { type: ScriptLoaderService }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], ControlWrapperComponent.prototype, "for", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ControlWrapperComponent.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ControlWrapperComponent.prototype, "options", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ControlWrapperComponent.prototype, "state", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], ControlWrapperComponent.prototype, "error", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], ControlWrapperComponent.prototype, "ready", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], ControlWrapperComponent.prototype, "stateChange", void 0);
__decorate([
    HostBinding('id'),
    __metadata("design:type", Object)
], ControlWrapperComponent.prototype, "id", void 0);
ControlWrapperComponent = __decorate([
    Component({
        selector: 'control-wrapper',
        template: '',
        host: { class: 'control-wrapper' },
        exportAs: 'controlWrapper',
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [ScriptLoaderService])
], ControlWrapperComponent);

let DashboardComponent = class DashboardComponent {
    constructor(element, loaderService) {
        this.element = element;
        this.loaderService = loaderService;
        /**
         * The dashboard has completed drawing and is ready to accept changes.
         *
         * The ready event will also fire:
         * - after the completion of a dashboard refresh triggered by a user or programmatic interaction with one of the controls,
         * - after redrawing any chart on the dashboard.
         */
        this.ready = new EventEmitter();
        /**
         * Emits when an error occurs when attempting to render the dashboard.
         * One or more of the controls and charts that are part of the dashboard may have failed rendering.
         */
        this.error = new EventEmitter();
        this.initialized = false;
    }
    ngOnInit() {
        this.loaderService.loadChartPackages('controls').subscribe(() => {
            this.createDataTable();
            this.createDashboard();
            this.initialized = true;
        });
    }
    ngOnChanges(changes) {
        if (!this.initialized) {
            return;
        }
        if (changes.data || changes.columns) {
            this.createDataTable();
            this.dashboard.draw(this.dataTable);
        }
    }
    createDashboard() {
        // TODO: This should happen in the control wrapper
        // However, I don't yet know how to do this because then `bind()` would get called multiple times
        // for the same control if something changes. This is not supported by google charts as far as I can tell
        // from their source code.
        const controlWrappersReady$ = this.controlWrappers.map(control => control.wrapperReady$);
        const chartsReady$ = this.controlWrappers
            .map(control => control.for)
            .map(charts => {
            if (Array.isArray(charts)) {
                // CombineLatest waits for all observables
                return combineLatest(charts.map(chart => chart.wrapperReady$));
            }
            else {
                return charts.wrapperReady$;
            }
        });
        // We have to wait for all chart wrappers and control wrappers to be initialized
        // before we can compose them together to create the dashboard
        combineLatest([...controlWrappersReady$, ...chartsReady$]).subscribe(() => {
            this.dashboard = new google.visualization.Dashboard(this.element.nativeElement);
            this.initializeBindings();
            this.dashboard.draw(this.dataTable);
        });
    }
    initializeBindings() {
        this.controlWrappers.forEach(control => {
            if (Array.isArray(control.for)) {
                const chartWrappers = control.for.map(chart => chart.chartWrapper);
                this.dashboard.bind(control.controlWrapper, chartWrappers);
            }
            else {
                this.dashboard.bind(control.controlWrapper, control.for.chartWrapper);
            }
        });
    }
    createDataTable() {
        if (this.data == null) {
            return;
        }
        let firstRowIsData = true;
        if (this.columns != null) {
            firstRowIsData = false;
        }
        this.dataTable = google.visualization.arrayToDataTable(this.getDataAsTable(), firstRowIsData);
    }
    getDataAsTable() {
        if (this.columns) {
            return [this.columns, ...this.data];
        }
        else {
            return this.data;
        }
    }
};
DashboardComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ScriptLoaderService }
];
__decorate([
    Input(),
    __metadata("design:type", Array)
], DashboardComponent.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], DashboardComponent.prototype, "columns", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], DashboardComponent.prototype, "ready", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], DashboardComponent.prototype, "error", void 0);
__decorate([
    ContentChildren(ControlWrapperComponent),
    __metadata("design:type", QueryList)
], DashboardComponent.prototype, "controlWrappers", void 0);
DashboardComponent = __decorate([
    Component({
        selector: 'dashboard',
        template: '<ng-content></ng-content>',
        changeDetection: ChangeDetectionStrategy.OnPush,
        exportAs: 'dashboard',
        host: { class: 'dashboard' }
    }),
    __metadata("design:paramtypes", [ElementRef, ScriptLoaderService])
], DashboardComponent);

let GoogleChartComponent = class GoogleChartComponent {
    constructor(element, scriptLoaderService, dashboard) {
        this.element = element;
        this.scriptLoaderService = scriptLoaderService;
        this.dashboard = dashboard;
        /**
         * The chart-specific options. All options listen in the Google Charts documentation applying
         * to the chart type specified can be used here.
         */
        this.options = {};
        /**
         * If this is set to `true`, the chart will be redrawn if the browser window is resized.
         * Defaults to `false` and should only be used when specifying the width or height of the chart
         * in percent.
         *
         * Note that this can impact performance.
         */
        this.dynamicResize = false;
        this.ready = new EventEmitter();
        this.error = new EventEmitter();
        this.select = new EventEmitter();
        this.mouseover = new EventEmitter();
        this.mouseleave = new EventEmitter();
        this.wrapperReadySubject = new ReplaySubject(1);
        this.initialized = false;
    }
    get chart() {
        if (!this.wrapper) {
            return null;
        }
        return this.wrapper.getChart();
    }
    get wrapperReady$() {
        return this.wrapperReadySubject.asObservable();
    }
    get chartWrapper() {
        return this.wrapper;
    }
    set chartWrapper(wrapper) {
        this.wrapper = wrapper;
        this.drawChart();
    }
    ngOnInit() {
        // We don't need to load any chart packages, the chart wrapper will handle this for us
        this.scriptLoaderService.loadChartPackages().subscribe(() => {
            this.createDataTable();
            // Only ever create the wrapper once to allow animations to happen when someting changes.
            this.wrapper = new google.visualization.ChartWrapper({
                container: this.element.nativeElement,
                chartType: this.type,
                dataTable: this.dataTable,
                options: this.mergeOptions()
            });
            this.registerChartEvents();
            this.wrapperReadySubject.next(this.wrapper);
            this.initialized = true;
            this.drawChart();
        });
    }
    ngOnChanges(changes) {
        if (changes.dynamicResize) {
            this.updateResizeListener();
        }
        if (this.initialized) {
            let shouldRedraw = false;
            if (changes.data || changes.columns || changes.formatters) {
                this.createDataTable();
                this.wrapper.setDataTable(this.dataTable);
                shouldRedraw = true;
            }
            if (changes.type) {
                this.wrapper.setChartType(this.type);
                shouldRedraw = true;
            }
            if (changes.options || changes.width || changes.height || changes.title) {
                this.wrapper.setOptions(this.mergeOptions());
                shouldRedraw = true;
            }
            if (shouldRedraw) {
                this.drawChart();
            }
        }
    }
    createDataTable() {
        if (this.data == null) {
            return;
        }
        let firstRowIsData = true;
        if (this.columns != null) {
            firstRowIsData = false;
        }
        this.dataTable = google.visualization.arrayToDataTable(this.getDataAsTable(), firstRowIsData);
        this.applyFormatters(this.dataTable);
    }
    getDataAsTable() {
        if (this.columns) {
            return [this.columns, ...this.data];
        }
        else {
            return this.data;
        }
    }
    updateResizeListener() {
        if (this.resizeSubscription != null) {
            this.resizeSubscription.unsubscribe();
            this.resizeSubscription = null;
        }
        if (this.dynamicResize) {
            this.resizeSubscription = fromEvent(window, 'resize')
                .pipe(debounceTime(100))
                .subscribe(() => {
                if (this.initialized) {
                    this.drawChart();
                }
            });
        }
    }
    mergeOptions() {
        return Object.assign({ title: this.title, width: this.width, height: this.height }, this.options);
    }
    applyFormatters(dataTable) {
        if (this.formatters == null) {
            return;
        }
        for (const val of this.formatters) {
            val.formatter.format(dataTable, val.colIndex);
        }
    }
    registerChartEvents() {
        google.visualization.events.removeAllListeners(this.wrapper);
        const registerChartEvent = (object, eventName, callback) => {
            google.visualization.events.addListener(object, eventName, callback);
        };
        registerChartEvent(this.wrapper, 'ready', () => {
            // This could also be done by checking if we already subscribed to the events
            google.visualization.events.removeAllListeners(this.chart);
            registerChartEvent(this.chart, 'onmouseover', (event) => this.mouseover.emit(event));
            registerChartEvent(this.chart, 'onmouseout', (event) => this.mouseleave.emit(event));
            registerChartEvent(this.chart, 'select', () => {
                const selection = this.chart.getSelection();
                this.select.emit({ selection });
            });
            this.ready.emit({ chart: this.chart });
        });
        registerChartEvent(this.wrapper, 'error', (error) => this.error.emit(error));
    }
    drawChart() {
        if (this.dashboard != null) {
            // If this chart is part of a dashboard, the dashboard takes care of drawing
            return;
        }
        this.wrapper.draw();
    }
};
GoogleChartComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ScriptLoaderService },
    { type: DashboardComponent, decorators: [{ type: Optional }] }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], GoogleChartComponent.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], GoogleChartComponent.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], GoogleChartComponent.prototype, "columns", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], GoogleChartComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], GoogleChartComponent.prototype, "width", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], GoogleChartComponent.prototype, "height", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], GoogleChartComponent.prototype, "options", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], GoogleChartComponent.prototype, "formatters", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], GoogleChartComponent.prototype, "dynamicResize", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], GoogleChartComponent.prototype, "ready", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], GoogleChartComponent.prototype, "error", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], GoogleChartComponent.prototype, "select", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], GoogleChartComponent.prototype, "mouseover", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], GoogleChartComponent.prototype, "mouseleave", void 0);
GoogleChartComponent = __decorate([
    Component({
        selector: 'google-chart',
        template: '',
        host: { class: 'google-chart' },
        exportAs: 'googleChart',
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [':host { width: fit-content; display: block; }']
    }),
    __param(2, Optional()),
    __metadata("design:paramtypes", [ElementRef,
        ScriptLoaderService,
        DashboardComponent])
], GoogleChartComponent);

let ChartWrapperComponent = class ChartWrapperComponent {
    constructor(element, scriptLoaderService) {
        this.element = element;
        this.scriptLoaderService = scriptLoaderService;
        this.error = new EventEmitter();
        this.ready = new EventEmitter();
        this.select = new EventEmitter();
        this.wrapperReadySubject = new ReplaySubject(1);
        this.initialized = false;
    }
    get chart() {
        if (!this.wrapper) {
            return null;
        }
        return this.wrapper.getChart();
    }
    get wrapperReady$() {
        return this.wrapperReadySubject.asObservable();
    }
    get chartWrapper() {
        return this.wrapper;
    }
    set chartWrapper(wrapper) {
        this.wrapper = wrapper;
        this.drawChart();
    }
    ngOnInit() {
        // We don't need to load any chart packages, the chart wrapper will handle this else for us
        this.scriptLoaderService.loadChartPackages().subscribe(() => {
            if (!this.specs) {
                this.specs = {};
            }
            const _a = this.specs, { containerId, container } = _a, specs = __rest(_a, ["containerId", "container"]);
            // Only ever create the wrapper once to allow animations to happen if something changes.
            this.wrapper = new google.visualization.ChartWrapper(Object.assign(Object.assign({}, specs), { container: this.element.nativeElement }));
            this.registerChartEvents();
            this.wrapperReadySubject.next(this.wrapper);
            this.drawChart();
            this.initialized = true;
        });
    }
    ngOnChanges(changes) {
        if (!this.initialized) {
            return;
        }
        if (changes.specs) {
            this.updateChart();
            this.drawChart();
        }
    }
    updateChart() {
        if (!this.specs) {
            // When creating the wrapper with empty specs, the google charts library will show an error
            // If we don't do this, a javascript error will be thrown, which is not as visible to the user
            this.specs = {};
        }
        this.wrapper.setChartType(this.specs.chartType);
        this.wrapper.setDataTable(this.specs.dataTable); // The typing here are not correct, this also accepts plain arrays
        this.wrapper.setDataSourceUrl(this.specs.dataSourceUrl);
        this.wrapper.setDataSourceUrl(this.specs.dataSourceUrl);
        this.wrapper.setQuery(this.specs.query);
        this.wrapper.setOptions(this.specs.options);
        this.wrapper.setRefreshInterval(this.specs.refreshInterval);
        this.wrapper.setView(this.specs.view);
    }
    drawChart() {
        this.wrapper.draw();
    }
    registerChartEvents() {
        google.visualization.events.removeAllListeners(this.wrapper);
        const registerChartEvent = (object, eventName, callback) => {
            google.visualization.events.addListener(object, eventName, callback);
        };
        registerChartEvent(this.wrapper, 'ready', () => this.ready.emit({ chart: this.chart }));
        registerChartEvent(this.wrapper, 'error', (error) => this.error.emit(error));
        registerChartEvent(this.wrapper, 'select', () => {
            const selection = this.chart.getSelection();
            this.select.emit({ selection });
        });
    }
};
ChartWrapperComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ScriptLoaderService }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartWrapperComponent.prototype, "specs", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], ChartWrapperComponent.prototype, "error", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], ChartWrapperComponent.prototype, "ready", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], ChartWrapperComponent.prototype, "select", void 0);
ChartWrapperComponent = __decorate([
    Component({
        selector: 'chart-wrapper',
        template: '',
        host: { class: 'chart-wrapper' },
        exportAs: 'chartWrapper',
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [':host { width: fit-content; display: block; }']
    }),
    __metadata("design:paramtypes", [ElementRef, ScriptLoaderService])
], ChartWrapperComponent);

const ChartTypesToPackages = {
    [ChartType.AnnotationChart]: 'annotationchart',
    [ChartType.AreaChart]: 'corechart',
    [ChartType.Bar]: 'bar',
    [ChartType.BarChart]: 'corechart',
    [ChartType.BubbleChart]: 'corechart',
    [ChartType.Calendar]: 'calendar',
    [ChartType.CandlestickChart]: 'corechart',
    [ChartType.ColumnChart]: 'corechart',
    [ChartType.ComboChart]: 'corechart',
    [ChartType.PieChart]: 'corechart',
    [ChartType.Gantt]: 'gantt',
    [ChartType.Gauge]: 'gauge',
    [ChartType.GeoChart]: 'geochart',
    [ChartType.Histogram]: 'corechart',
    [ChartType.Line]: 'line',
    [ChartType.LineChart]: 'corechart',
    [ChartType.Map]: 'map',
    [ChartType.OrgChart]: 'orgchart',
    [ChartType.Sankey]: 'sankey',
    [ChartType.Scatter]: 'scatter',
    [ChartType.ScatterChart]: 'corechart',
    [ChartType.SteppedAreaChart]: 'corechart',
    [ChartType.Table]: 'table',
    [ChartType.Timeline]: 'timeline',
    [ChartType.TreeMap]: 'treemap',
    [ChartType.WordTree]: 'wordtree'
};
function getPackageForChart(type) {
    return ChartTypesToPackages[type];
}

var GoogleChartsModule_1;
let GoogleChartsModule = GoogleChartsModule_1 = class GoogleChartsModule {
    static forRoot(config = {}) {
        return {
            ngModule: GoogleChartsModule_1,
            providers: [{ provide: GOOGLE_CHARTS_CONFIG, useValue: config }]
        };
    }
};
GoogleChartsModule = GoogleChartsModule_1 = __decorate([
    NgModule({
        declarations: [GoogleChartComponent, ChartWrapperComponent, DashboardComponent, ControlWrapperComponent, ChartEditorComponent],
        exports: [GoogleChartComponent, ChartWrapperComponent, DashboardComponent, ControlWrapperComponent, ChartEditorComponent]
    })
], GoogleChartsModule);

/*
 * Public API Surface of angular-google-charts
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ChartEditorComponent, ChartEditorRef, ChartType, ChartWrapperComponent, ControlWrapperComponent, DashboardComponent, FilterType, GoogleChartComponent, GoogleChartsModule, ScriptLoaderService, getPackageForChart, GOOGLE_CHARTS_CONFIG as ɵa };
//# sourceMappingURL=angular-google-charts.js.map
