import { __decorate, __metadata } from "tslib";
import { ChangeDetectionStrategy, Component, ContentChildren, ElementRef, EventEmitter, Input, OnChanges, OnInit, Output, QueryList, SimpleChanges } from '@angular/core';
import { combineLatest } from 'rxjs';
import { ScriptLoaderService } from '../../script-loader/script-loader.service';
import { ControlWrapperComponent } from '../control-wrapper/control-wrapper.component';
let DashboardComponent = class DashboardComponent {
    constructor(element, loaderService) {
        this.element = element;
        this.loaderService = loaderService;
        /**
         * The dashboard has completed drawing and is ready to accept changes.
         *
         * The ready event will also fire:
         * - after the completion of a dashboard refresh triggered by a user or programmatic interaction with one of the controls,
         * - after redrawing any chart on the dashboard.
         */
        this.ready = new EventEmitter();
        /**
         * Emits when an error occurs when attempting to render the dashboard.
         * One or more of the controls and charts that are part of the dashboard may have failed rendering.
         */
        this.error = new EventEmitter();
        this.initialized = false;
    }
    ngOnInit() {
        this.loaderService.loadChartPackages('controls').subscribe(() => {
            this.createDataTable();
            this.createDashboard();
            this.initialized = true;
        });
    }
    ngOnChanges(changes) {
        if (!this.initialized) {
            return;
        }
        if (changes.data || changes.columns) {
            this.createDataTable();
            this.dashboard.draw(this.dataTable);
        }
    }
    createDashboard() {
        // TODO: This should happen in the control wrapper
        // However, I don't yet know how to do this because then `bind()` would get called multiple times
        // for the same control if something changes. This is not supported by google charts as far as I can tell
        // from their source code.
        const controlWrappersReady$ = this.controlWrappers.map(control => control.wrapperReady$);
        const chartsReady$ = this.controlWrappers
            .map(control => control.for)
            .map(charts => {
            if (Array.isArray(charts)) {
                // CombineLatest waits for all observables
                return combineLatest(charts.map(chart => chart.wrapperReady$));
            }
            else {
                return charts.wrapperReady$;
            }
        });
        // We have to wait for all chart wrappers and control wrappers to be initialized
        // before we can compose them together to create the dashboard
        combineLatest([...controlWrappersReady$, ...chartsReady$]).subscribe(() => {
            this.dashboard = new google.visualization.Dashboard(this.element.nativeElement);
            this.initializeBindings();
            this.dashboard.draw(this.dataTable);
        });
    }
    initializeBindings() {
        this.controlWrappers.forEach(control => {
            if (Array.isArray(control.for)) {
                const chartWrappers = control.for.map(chart => chart.chartWrapper);
                this.dashboard.bind(control.controlWrapper, chartWrappers);
            }
            else {
                this.dashboard.bind(control.controlWrapper, control.for.chartWrapper);
            }
        });
    }
    createDataTable() {
        if (this.data == null) {
            return;
        }
        let firstRowIsData = true;
        if (this.columns != null) {
            firstRowIsData = false;
        }
        this.dataTable = google.visualization.arrayToDataTable(this.getDataAsTable(), firstRowIsData);
    }
    getDataAsTable() {
        if (this.columns) {
            return [this.columns, ...this.data];
        }
        else {
            return this.data;
        }
    }
};
DashboardComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ScriptLoaderService }
];
__decorate([
    Input(),
    __metadata("design:type", Array)
], DashboardComponent.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], DashboardComponent.prototype, "columns", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], DashboardComponent.prototype, "ready", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], DashboardComponent.prototype, "error", void 0);
__decorate([
    ContentChildren(ControlWrapperComponent),
    __metadata("design:type", QueryList)
], DashboardComponent.prototype, "controlWrappers", void 0);
DashboardComponent = __decorate([
    Component({
        selector: 'dashboard',
        template: '<ng-content></ng-content>',
        changeDetection: ChangeDetectionStrategy.OnPush,
        exportAs: 'dashboard',
        host: { class: 'dashboard' }
    }),
    __metadata("design:paramtypes", [ElementRef, ScriptLoaderService])
], DashboardComponent);
export { DashboardComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGFzaGJvYXJkLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItZ29vZ2xlLWNoYXJ0cy8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL2Rhc2hib2FyZC9kYXNoYm9hcmQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxlQUFlLEVBQ2YsVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEVBQ0wsU0FBUyxFQUNULE1BQU0sRUFDTixNQUFNLEVBQ04sU0FBUyxFQUNULGFBQWEsRUFDZCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBR3JDLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDJDQUEyQyxDQUFDO0FBRWhGLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLDhDQUE4QyxDQUFDO0FBU3ZGLElBQWEsa0JBQWtCLEdBQS9CLE1BQWEsa0JBQWtCO0lBMEM3QixZQUFvQixPQUFtQixFQUFVLGFBQWtDO1FBQS9ELFlBQU8sR0FBUCxPQUFPLENBQVk7UUFBVSxrQkFBYSxHQUFiLGFBQWEsQ0FBcUI7UUF4Qm5GOzs7Ozs7V0FNRztRQUVJLFVBQUssR0FBRyxJQUFJLFlBQVksRUFBUSxDQUFDO1FBRXhDOzs7V0FHRztRQUVJLFVBQUssR0FBRyxJQUFJLFlBQVksRUFBbUIsQ0FBQztRQU8zQyxnQkFBVyxHQUFHLEtBQUssQ0FBQztJQUUwRCxDQUFDO0lBRWhGLFFBQVE7UUFDYixJQUFJLENBQUMsYUFBYSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDOUQsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQ3ZCLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUN2QixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztRQUMxQixDQUFDLENB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QixJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDaEIsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDckM7YUFBTTtZQUNMLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztTQUNsQjtJQUNILENBQUM7Q0FDRixDQUFBOztZQTlFOEIsVUFBVTtZQUF5QixtQkFBbUI7O0FBbkNuRjtJQURDLEtBQUssRUFBRTs7Z0RBQ1k7QUFTcEI7SUFEQyxLQUFLLEVBQUU7O21EQUNpQjtBQVV6QjtJQURDLE1BQU0sRUFBRTs7aURBQytCO0FBT3hDO0lBREMsTUFBTSxFQUFFOztpREFDMEM7QUFHbkQ7SUFEQyxlQUFlLENBQUMsdUJBQXVCLENBQUM7OEJBQ2hCLFNBQVM7MkRBQTBCO0FBcENqRCxrQkFBa0I7SUFQOUIsU0FBUyxDQUFDO1FBQ1QsUUFBUSxFQUFFLFdBQVc7UUFDckIsUUFBUSxFQUFFLDJCQUEyQjtRQUNyQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtRQUMvQyxRQUFRLEVBQUUsV0FBVztRQUNyQixJQUFJLEVBQUUsRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFO0tBQzdCLENBQUM7cUNBMkM2QixVQUFVLEVBQXlCLG1CQUFtQjtHQTFDeEUsa0JBQWtCLENBd0g5QjtTQXhIWSxrQkFBa0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25Jbml0LFxuICBPdXRwdXQsXG4gIFF1ZXJ5TGlzdCxcbiAgU2ltcGxlQ2hhbmdlc1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGNvbWJpbmVMYXRlc3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgQ2hhcnRFcnJvckV2ZW50IH0gZnJvbSAnLi4vLi4vbW9kZWxzL2V2ZW50cy5tb2RlbCc7XG5pbXBvcnQgeyBTY3JpcHRMb2FkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2NyaXB0LWxvYWRlci9zY3JpcHQtbG9hZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29sdW1uLCBSb3cgfSBmcm9tICcuLi9jaGFydC1iYXNlL2NoYXJ0LWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IENvbnRyb2xXcmFwcGVyQ29tcG9uZW50IH0gZnJvbSAnLi4vY29udHJvbC13cmFwcGVyL2NvbnRyb2wtd3JhcHBlci5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdkYXNoYm9hcmQnLFxuICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgZXhwb3J0QXM6ICdkYXNoYm9hcmQnLFxuICBob3N0OiB7IGNsYXNzOiAnZGFzaGJvYXJkJyB9XG59KVxuZXhwb3J0IGNsYXNzIERhc2hib2FyZENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgLyoqXG4gICAqIERhdGEgdXNlZCB0byBpbml0aWFsaXplIHRoZSB0YWJsZS5cbiAgICpcbiAgICogVGhpcyBtdXN0IGFsc28gY29udGFpbiBhbGwgcm9sZXMgdGhhdCBhcmUgc2V0IGluIHRoZSBgY29sdW1uc2AgcHJvcGVydHkuXG4gICAqL1xuICBASW5wdXQoKVxuICBwdWJsaWMgZGF0YSE6IFJvd1tdO1xuXG4gIC8qKlxuICAgKiBUaGUgY29sdW1ucyB0aGUgYGRhdGFgIGNvbnNpc3RzIG9mLlxuICAgKiBUaGUgbGVuZ3RoIG9mIHRoaXMgYXJyYXkgbXVzdCBtYXRjaCB0aGUgbGVuZ3RoIG9mIGVhY2ggcm93IGluIHRoZSBgZGF0YWAgb2JqZWN0LlxuICAgKlxuICAgKiBJZiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vY2hhcnQvaW50ZXJhY3RpdmUvZG9jcy9yb2xlcyByb2xlc30gc2hvdWxkIGJlIGFwcGxpZWQsIHRoZXkgbXVzdCBiZSBpbmNsdWRlZCBpbiB0aGlzIGFycmF5IGFzIHdlbGwuXG4gICAqL1xuICBASW5wdXQoKVxuICBwdWJsaWMgY29sdW1uczogQ29sdW1uW107XG5cbiAgLyoqXG4gICAqIFRoZSBkYXNoYm9hcmQgaGFzIGNvbXBsZXRlZCBkcmF3aW5nIGFuZCBpcyByZWFkeSB0byBhY2NlcHQgY2hhbmdlcy5cbiAgICpcbiAgICogVGhlIHJlYWR5IGV2ZW50IHdpbGwgYWxzbyBmaXJlOlxuICAgKiAtIGFmdGVyIHRoZSBjb21wbGV0aW9uIG9mIGEgZGFzaGJvYXJkIHJlZnJlc2ggdHJpZ2dlcmVkIGJ5IGEgdXNlciBvciBwcm9ncmFtbWF0aWMgaW50ZXJhY3Rpb24gd2l0aCBvbmUgb2YgdGhlIGNvbnRyb2xzLFxuICAgKiAtIGFmdGVyIHJlZHJhd2luZyBhbnkgY2hhcnQgb24gdGhlIGRhc2hib2FyZC5cbiAgICovXG4gIEBPdXRwdXQoKVxuICBwdWJsaWMgcmVhZHkgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIHdoZW4gYW4gZXJyb3Igb2NjdXJzIHdoZW4gYXR0ZW1wdGluZyB0byByZW5kZXIgdGhlIGRhc2hib2FyZC5cbiAgICogT25lIG9yIG1vcmUgb2YgdGhlIGNvbnRyb2xzIGFuZCBjaGFydHMgdGhhdCBhcmUgcGFydCBvZiB0aGUgZGFzaGJvYXJkIG1heSBoYXZlIGZhaWxlZCByZW5kZXJpbmcuXG4gICAqL1xuICBAT3V0cHV0KClcbiAgcHVibGljIGVycm9yID0gbmV3IEV2ZW50RW1pdHRlcjxDaGFydEVycm9yRXZlbnQ+KCk7XG5cbiAgQENvbnRlbnRDaGlsZHJlbihDb250cm9sV3JhcHBlckNvbXBvbmVudClcbiAgcHJpdmF0ZSBjb250cm9sV3JhcHBlcnM6IFF1ZXJ5TGlzdDxDb250cm9sV3JhcHBlckNvbXBvbmVudD47XG5cbiAgcHJpdmF0ZSBkYXNoYm9hcmQ6IGdvb2dsZS52aXN1YWxpemF0aW9uLkRhc2hib2FyZDtcbiAgcHJpdmF0ZSBkYXRhVGFibGU6IGdvb2dsZS52aXN1YWxpemF0aW9uLkRhdGFUYWJsZTtcbiAgcHJpdmF0ZSBpbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZiwgcHJpdmF0ZSBsb2FkZXJTZXJ2aWNlOiBTY3JpcHRMb2FkZXJTZXJ2aWNlKSB7fVxuXG4gIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLmxvYWRlclNlcnZpY2UubG9hZENoYXJ0UGFja2FnZXMoJ2NvbnRyb2xzJykuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuY3JlYXRlRGF0YVRhYmxlKCk7XG4gICAgICB0aGlzLmNyZWF0ZURhc2hib2FyZCgpO1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VzLmRhdGEgfHwgY2hhbmdlcy5jb2x1bW5zKSB7XG4gICAgICB0aGlzLmNyZWF0ZURhdGFUYWJsZSgpO1xuICAgICAgdGhpcy5kYXNoYm9hcmQuZHJhdyh0aGlzLmRhdGFUYWJsZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVEYXNoYm9hcmQoKSB7XG4gICAgLy8gVE9ETzogVGhpcyBzaG91bGQgaGFwcGVuIGluIHRoZSBjb250cm9sIHdyYXBwZXJcbiAgICAvLyBIb3dldmVyLCBJIGRvbid0IHlldCBrbm93IGhvdyB0byBkbyB0aGlzIGJlY2F1c2UgdGhlbiBgYmluZCgpYCB3b3VsZCBnZXQgY2FsbGVkIG11bHRpcGxlIHRpbWVzXG4gICAgLy8gZm9yIHRoZSBzYW1lIGNvbnRyb2wgaWYgc29tZXRoaW5nIGNoYW5nZXMuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBieSBnb29nbGUgY2hhcnRzIGFzIGZhciBhcyBJIGNhbiB0ZWxsXG4gICAgLy8gZnJvbSB0aGVpciBzb3VyY2UgY29kZS5cbiAgICBjb25zdCBjb250cm9sV3JhcHBlcnNSZWFkeSQgPSB0aGlzLmNvbnRyb2xXcmFwcGVycy5tYXAoY29udHJvbCA9PiBjb250cm9sLndyYXBwZXJSZWFkeSQpO1xuICAgIGNvbnN0IGNoYXJ0c1JlYWR5JCA9IHRoaXMuY29udHJvbFdyYXBwZXJzXG4gICAgICAubWFwKGNvbnRyb2wgPT4gY29udHJvbC5mb3IpXG4gICAgICAubWFwKGNoYXJ0cyA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoYXJ0cykpIHtcbiAgICAgICAgICAvLyBDb21iaW5lTGF0ZXN0IHdhaXRzIGZvciBhbGwgb2JzZXJ2YWJsZXNcbiAgICAgICAgICByZXR1cm4gY29tYmluZUxhdGVzdChjaGFydHMubWFwKGNoYXJ0ID0+IGNoYXJ0LndyYXBwZXJSZWFkeSQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2hhcnRzLndyYXBwZXJSZWFkeSQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgLy8gV2UgaGF2ZSB0byB3YWl0IGZvciBhbGwgY2hhcnQgd3JhcHBlcnMgYW5kIGNvbnRyb2wgd3JhcHBlcnMgdG8gYmUgaW5pdGlhbGl6ZWRcbiAgICAvLyBiZWZvcmUgd2UgY2FuIGNvbXBvc2UgdGhlbSB0b2dldGhlciB0byBjcmVhdGUgdGhlIGRhc2hib2FyZFxuICAgIGNvbWJpbmVMYXRlc3QoWy4uLmNvbnRyb2xXcmFwcGVyc1JlYWR5JCwgLi4uY2hhcnRzUmVhZHkkXSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuZGFzaGJvYXJkID0gbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLkRhc2hib2FyZCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICB0aGlzLmluaXRpYWxpemVCaW5kaW5ncygpO1xuICAgICAgdGhpcy5kYXNoYm9hcmQuZHJhdyh0aGlzLmRhdGFUYWJsZSk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGluaXRpYWxpemVCaW5kaW5ncygpIHtcbiAgICB0aGlzLmNvbnRyb2xXcmFwcGVycy5mb3JFYWNoKGNvbnRyb2wgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udHJvbC5mb3IpKSB7XG4gICAgICAgIGNvbnN0IGNoYXJ0V3JhcHBlcnMgPSBjb250cm9sLmZvci5tYXAoY2hhcnQgPT4gY2hhcnQuY2hhcnRXcmFwcGVyKTtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmQuYmluZChjb250cm9sLmNvbnRyb2xXcmFwcGVyLCBjaGFydFdyYXBwZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGFzaGJvYXJkLmJpbmQoY29udHJvbC5jb250cm9sV3JhcHBlciwgY29udHJvbC5mb3IuY2hhcnRXcmFwcGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRGF0YVRhYmxlKCkge1xuICAgIGlmICh0aGlzLmRhdGEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBmaXJzdFJvd0lzRGF0YSA9IHRydWU7XG4gICAgaWYgKHRoaXMuY29sdW1ucyAhPSBudWxsKSB7XG4gICAgICBmaXJzdFJvd0lzRGF0YSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YVRhYmxlID0gZ29vZ2xlLnZpc3VhbGl6YXRpb24uYXJyYXlUb0RhdGFUYWJsZSh0aGlzLmdldERhdGFBc1RhYmxlKCksIGZpcnN0Um93SXNEYXRhKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGF0YUFzVGFibGUoKTogKFJvdyB8IENvbHVtbltdKVtdIHtcbiAgICBpZiAodGhpcy5jb2x1bW5zKSB7XG4gICAgICByZXR1cm4gW3RoaXMuY29sdW1ucywgLi4udGhpcy5kYXRhXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==